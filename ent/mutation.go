// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/lingfohn/lime/ent/application"
	"github.com/lingfohn/lime/ent/build"
	"github.com/lingfohn/lime/ent/helmconfig"
	"github.com/lingfohn/lime/ent/instance"
	"github.com/lingfohn/lime/ent/k8scluster"
	"github.com/lingfohn/lime/ent/menu"
	"github.com/lingfohn/lime/ent/namespace"
	"github.com/lingfohn/lime/ent/permission"
	"github.com/lingfohn/lime/ent/predicate"
	"github.com/lingfohn/lime/ent/project"
	"github.com/lingfohn/lime/ent/role"
	"github.com/lingfohn/lime/ent/user"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication = "Application"
	TypeBuild       = "Build"
	TypeHelmConfig  = "HelmConfig"
	TypeInstance    = "Instance"
	TypeK8sCluster  = "K8sCluster"
	TypeMenu        = "Menu"
	TypeNamespace   = "Namespace"
	TypePermission  = "Permission"
	TypeProject     = "Project"
	TypeRole        = "Role"
	TypeUser        = "User"
)

// ApplicationMutation represents an operation that mutate the Applications
// nodes in the graph.
type ApplicationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	multi            *bool
	projectId        *int
	addprojectId     *int
	namespaceId      *int
	addnamespaceId   *int
	createdAt        *time.Time
	updatedAt        *time.Time
	clearedFields    map[string]struct{}
	namespace        *int
	clearednamespace bool
	project          *int
	clearedproject   bool
	instances        map[int]struct{}
	removedinstances map[int]struct{}
	clearedinstances bool
	_config          *int
	cleared_config   bool
	done             bool
	oldValue         func(context.Context) (*Application, error)
	predicates       []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows to manage the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for $n.Name.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the id field of the mutation.
func withApplicationID(id int) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ApplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Application.
// If the Application object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
}

// SetMulti sets the multi field.
func (m *ApplicationMutation) SetMulti(b bool) {
	m.multi = &b
}

// Multi returns the multi value in the mutation.
func (m *ApplicationMutation) Multi() (r bool, exists bool) {
	v := m.multi
	if v == nil {
		return
	}
	return *v, true
}

// OldMulti returns the old multi value of the Application.
// If the Application object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ApplicationMutation) OldMulti(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMulti is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMulti requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMulti: %w", err)
	}
	return oldValue.Multi, nil
}

// ResetMulti reset all changes of the "multi" field.
func (m *ApplicationMutation) ResetMulti() {
	m.multi = nil
}

// SetProjectId sets the projectId field.
func (m *ApplicationMutation) SetProjectId(i int) {
	m.projectId = &i
	m.addprojectId = nil
}

// ProjectId returns the projectId value in the mutation.
func (m *ApplicationMutation) ProjectId() (r int, exists bool) {
	v := m.projectId
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectId returns the old projectId value of the Application.
// If the Application object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ApplicationMutation) OldProjectId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProjectId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectId: %w", err)
	}
	return oldValue.ProjectId, nil
}

// AddProjectId adds i to projectId.
func (m *ApplicationMutation) AddProjectId(i int) {
	if m.addprojectId != nil {
		*m.addprojectId += i
	} else {
		m.addprojectId = &i
	}
}

// AddedProjectId returns the value that was added to the projectId field in this mutation.
func (m *ApplicationMutation) AddedProjectId() (r int, exists bool) {
	v := m.addprojectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectId reset all changes of the "projectId" field.
func (m *ApplicationMutation) ResetProjectId() {
	m.projectId = nil
	m.addprojectId = nil
}

// SetNamespaceId sets the namespaceId field.
func (m *ApplicationMutation) SetNamespaceId(i int) {
	m.namespaceId = &i
	m.addnamespaceId = nil
}

// NamespaceId returns the namespaceId value in the mutation.
func (m *ApplicationMutation) NamespaceId() (r int, exists bool) {
	v := m.namespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceId returns the old namespaceId value of the Application.
// If the Application object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ApplicationMutation) OldNamespaceId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNamespaceId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceId: %w", err)
	}
	return oldValue.NamespaceId, nil
}

// AddNamespaceId adds i to namespaceId.
func (m *ApplicationMutation) AddNamespaceId(i int) {
	if m.addnamespaceId != nil {
		*m.addnamespaceId += i
	} else {
		m.addnamespaceId = &i
	}
}

// AddedNamespaceId returns the value that was added to the namespaceId field in this mutation.
func (m *ApplicationMutation) AddedNamespaceId() (r int, exists bool) {
	v := m.addnamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNamespaceId reset all changes of the "namespaceId" field.
func (m *ApplicationMutation) ResetNamespaceId() {
	m.namespaceId = nil
	m.addnamespaceId = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ApplicationMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Application.
// If the Application object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ApplicationMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Application.
// If the Application object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ApplicationMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetNamespaceID sets the namespace edge to Namespace by id.
func (m *ApplicationMutation) SetNamespaceID(id int) {
	m.namespace = &id
}

// ClearNamespace clears the namespace edge to Namespace.
func (m *ApplicationMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared returns if the edge namespace was cleared.
func (m *ApplicationMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the namespace id in the mutation.
func (m *ApplicationMutation) NamespaceID() (id int, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the namespace ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace reset all changes of the "namespace" edge.
func (m *ApplicationMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetProjectID sets the project edge to Project by id.
func (m *ApplicationMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the project edge to Project.
func (m *ApplicationMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared returns if the edge project was cleared.
func (m *ApplicationMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the project id in the mutation.
func (m *ApplicationMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the project ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject reset all changes of the "project" edge.
func (m *ApplicationMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddInstanceIDs adds the instances edge to Instance by ids.
func (m *ApplicationMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the instances edge to Instance.
func (m *ApplicationMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared returns if the edge instances was cleared.
func (m *ApplicationMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the instances edge to Instance by ids.
func (m *ApplicationMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed ids of instances.
func (m *ApplicationMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the instances ids in the mutation.
func (m *ApplicationMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances reset all changes of the "instances" edge.
func (m *ApplicationMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// SetConfigID sets the config edge to HelmConfig by id.
func (m *ApplicationMutation) SetConfigID(id int) {
	m._config = &id
}

// ClearConfig clears the config edge to HelmConfig.
func (m *ApplicationMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared returns if the edge config was cleared.
func (m *ApplicationMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the config id in the mutation.
func (m *ApplicationMutation) ConfigID() (id int, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the config ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ConfigIDs() (ids []int) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig reset all changes of the "config" edge.
func (m *ApplicationMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	if m.multi != nil {
		fields = append(fields, application.FieldMulti)
	}
	if m.projectId != nil {
		fields = append(fields, application.FieldProjectId)
	}
	if m.namespaceId != nil {
		fields = append(fields, application.FieldNamespaceId)
	}
	if m.createdAt != nil {
		fields = append(fields, application.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, application.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldName:
		return m.Name()
	case application.FieldMulti:
		return m.Multi()
	case application.FieldProjectId:
		return m.ProjectId()
	case application.FieldNamespaceId:
		return m.NamespaceId()
	case application.FieldCreatedAt:
		return m.CreatedAt()
	case application.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldName:
		return m.OldName(ctx)
	case application.FieldMulti:
		return m.OldMulti(ctx)
	case application.FieldProjectId:
		return m.OldProjectId(ctx)
	case application.FieldNamespaceId:
		return m.OldNamespaceId(ctx)
	case application.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case application.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case application.FieldMulti:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMulti(v)
		return nil
	case application.FieldProjectId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectId(v)
		return nil
	case application.FieldNamespaceId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceId(v)
		return nil
	case application.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case application.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	var fields []string
	if m.addprojectId != nil {
		fields = append(fields, application.FieldProjectId)
	}
	if m.addnamespaceId != nil {
		fields = append(fields, application.FieldNamespaceId)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case application.FieldProjectId:
		return m.AddedProjectId()
	case application.FieldNamespaceId:
		return m.AddedNamespaceId()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case application.FieldProjectId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectId(v)
		return nil
	case application.FieldNamespaceId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNamespaceId(v)
		return nil
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldName:
		m.ResetName()
		return nil
	case application.FieldMulti:
		m.ResetMulti()
		return nil
	case application.FieldProjectId:
		m.ResetProjectId()
		return nil
	case application.FieldNamespaceId:
		m.ResetNamespaceId()
		return nil
	case application.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.namespace != nil {
		edges = append(edges, application.EdgeNamespace)
	}
	if m.project != nil {
		edges = append(edges, application.EdgeProject)
	}
	if m.instances != nil {
		edges = append(edges, application.EdgeInstances)
	}
	if m._config != nil {
		edges = append(edges, application.EdgeConfig)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinstances != nil {
		edges = append(edges, application.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednamespace {
		edges = append(edges, application.EdgeNamespace)
	}
	if m.clearedproject {
		edges = append(edges, application.EdgeProject)
	}
	if m.clearedinstances {
		edges = append(edges, application.EdgeInstances)
	}
	if m.cleared_config {
		edges = append(edges, application.EdgeConfig)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeNamespace:
		return m.clearednamespace
	case application.EdgeProject:
		return m.clearedproject
	case application.EdgeInstances:
		return m.clearedinstances
	case application.EdgeConfig:
		return m.cleared_config
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case application.EdgeProject:
		m.ClearProject()
		return nil
	case application.EdgeConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case application.EdgeProject:
		m.ResetProject()
		return nil
	case application.EdgeInstances:
		m.ResetInstances()
		return nil
	case application.EdgeConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// BuildMutation represents an operation that mutate the Builds
// nodes in the graph.
type BuildMutation struct {
	config
	op                Op
	typ               string
	id                *int
	tag               *string
	name              *string
	status            *int
	addstatus         *int
	commitId          *string
	shortId           *string
	message           *string
	committerName     *string
	committedData     *time.Time
	buildTime         *time.Time
	jenkinsQueueId    *int
	addjenkinsQueueId *int
	jenkinsBuildId    *int
	addjenkinsBuildId *int
	createdAt         *time.Time
	updatedAt         *time.Time
	clearedFields     map[string]struct{}
	instance          *int
	clearedinstance   bool
	done              bool
	oldValue          func(context.Context) (*Build, error)
	predicates        []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows to manage the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for $n.Name.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the id field of the mutation.
func withBuildID(id int) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BuildMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTag sets the tag field.
func (m *BuildMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the tag value in the mutation.
func (m *BuildMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old tag value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag reset all changes of the "tag" field.
func (m *BuildMutation) ResetTag() {
	m.tag = nil
}

// SetName sets the name field.
func (m *BuildMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BuildMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BuildMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the status field.
func (m *BuildMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *BuildMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *BuildMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *BuildMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *BuildMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCommitId sets the commitId field.
func (m *BuildMutation) SetCommitId(s string) {
	m.commitId = &s
}

// CommitId returns the commitId value in the mutation.
func (m *BuildMutation) CommitId() (r string, exists bool) {
	v := m.commitId
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitId returns the old commitId value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldCommitId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommitId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommitId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitId: %w", err)
	}
	return oldValue.CommitId, nil
}

// ResetCommitId reset all changes of the "commitId" field.
func (m *BuildMutation) ResetCommitId() {
	m.commitId = nil
}

// SetShortId sets the shortId field.
func (m *BuildMutation) SetShortId(s string) {
	m.shortId = &s
}

// ShortId returns the shortId value in the mutation.
func (m *BuildMutation) ShortId() (r string, exists bool) {
	v := m.shortId
	if v == nil {
		return
	}
	return *v, true
}

// OldShortId returns the old shortId value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldShortId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShortId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShortId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortId: %w", err)
	}
	return oldValue.ShortId, nil
}

// ResetShortId reset all changes of the "shortId" field.
func (m *BuildMutation) ResetShortId() {
	m.shortId = nil
}

// SetMessage sets the message field.
func (m *BuildMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the message value in the mutation.
func (m *BuildMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old message value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage reset all changes of the "message" field.
func (m *BuildMutation) ResetMessage() {
	m.message = nil
}

// SetCommitterName sets the committerName field.
func (m *BuildMutation) SetCommitterName(s string) {
	m.committerName = &s
}

// CommitterName returns the committerName value in the mutation.
func (m *BuildMutation) CommitterName() (r string, exists bool) {
	v := m.committerName
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitterName returns the old committerName value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldCommitterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommitterName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommitterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitterName: %w", err)
	}
	return oldValue.CommitterName, nil
}

// ResetCommitterName reset all changes of the "committerName" field.
func (m *BuildMutation) ResetCommitterName() {
	m.committerName = nil
}

// SetCommittedData sets the committedData field.
func (m *BuildMutation) SetCommittedData(t time.Time) {
	m.committedData = &t
}

// CommittedData returns the committedData value in the mutation.
func (m *BuildMutation) CommittedData() (r time.Time, exists bool) {
	v := m.committedData
	if v == nil {
		return
	}
	return *v, true
}

// OldCommittedData returns the old committedData value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldCommittedData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommittedData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommittedData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommittedData: %w", err)
	}
	return oldValue.CommittedData, nil
}

// ResetCommittedData reset all changes of the "committedData" field.
func (m *BuildMutation) ResetCommittedData() {
	m.committedData = nil
}

// SetBuildTime sets the buildTime field.
func (m *BuildMutation) SetBuildTime(t time.Time) {
	m.buildTime = &t
}

// BuildTime returns the buildTime value in the mutation.
func (m *BuildMutation) BuildTime() (r time.Time, exists bool) {
	v := m.buildTime
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildTime returns the old buildTime value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldBuildTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuildTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuildTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildTime: %w", err)
	}
	return oldValue.BuildTime, nil
}

// ResetBuildTime reset all changes of the "buildTime" field.
func (m *BuildMutation) ResetBuildTime() {
	m.buildTime = nil
}

// SetJenkinsQueueId sets the jenkinsQueueId field.
func (m *BuildMutation) SetJenkinsQueueId(i int) {
	m.jenkinsQueueId = &i
	m.addjenkinsQueueId = nil
}

// JenkinsQueueId returns the jenkinsQueueId value in the mutation.
func (m *BuildMutation) JenkinsQueueId() (r int, exists bool) {
	v := m.jenkinsQueueId
	if v == nil {
		return
	}
	return *v, true
}

// OldJenkinsQueueId returns the old jenkinsQueueId value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldJenkinsQueueId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJenkinsQueueId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJenkinsQueueId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJenkinsQueueId: %w", err)
	}
	return oldValue.JenkinsQueueId, nil
}

// AddJenkinsQueueId adds i to jenkinsQueueId.
func (m *BuildMutation) AddJenkinsQueueId(i int) {
	if m.addjenkinsQueueId != nil {
		*m.addjenkinsQueueId += i
	} else {
		m.addjenkinsQueueId = &i
	}
}

// AddedJenkinsQueueId returns the value that was added to the jenkinsQueueId field in this mutation.
func (m *BuildMutation) AddedJenkinsQueueId() (r int, exists bool) {
	v := m.addjenkinsQueueId
	if v == nil {
		return
	}
	return *v, true
}

// ResetJenkinsQueueId reset all changes of the "jenkinsQueueId" field.
func (m *BuildMutation) ResetJenkinsQueueId() {
	m.jenkinsQueueId = nil
	m.addjenkinsQueueId = nil
}

// SetJenkinsBuildId sets the jenkinsBuildId field.
func (m *BuildMutation) SetJenkinsBuildId(i int) {
	m.jenkinsBuildId = &i
	m.addjenkinsBuildId = nil
}

// JenkinsBuildId returns the jenkinsBuildId value in the mutation.
func (m *BuildMutation) JenkinsBuildId() (r int, exists bool) {
	v := m.jenkinsBuildId
	if v == nil {
		return
	}
	return *v, true
}

// OldJenkinsBuildId returns the old jenkinsBuildId value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldJenkinsBuildId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJenkinsBuildId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJenkinsBuildId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJenkinsBuildId: %w", err)
	}
	return oldValue.JenkinsBuildId, nil
}

// AddJenkinsBuildId adds i to jenkinsBuildId.
func (m *BuildMutation) AddJenkinsBuildId(i int) {
	if m.addjenkinsBuildId != nil {
		*m.addjenkinsBuildId += i
	} else {
		m.addjenkinsBuildId = &i
	}
}

// AddedJenkinsBuildId returns the value that was added to the jenkinsBuildId field in this mutation.
func (m *BuildMutation) AddedJenkinsBuildId() (r int, exists bool) {
	v := m.addjenkinsBuildId
	if v == nil {
		return
	}
	return *v, true
}

// ClearJenkinsBuildId clears the value of jenkinsBuildId.
func (m *BuildMutation) ClearJenkinsBuildId() {
	m.jenkinsBuildId = nil
	m.addjenkinsBuildId = nil
	m.clearedFields[build.FieldJenkinsBuildId] = struct{}{}
}

// JenkinsBuildIdCleared returns if the field jenkinsBuildId was cleared in this mutation.
func (m *BuildMutation) JenkinsBuildIdCleared() bool {
	_, ok := m.clearedFields[build.FieldJenkinsBuildId]
	return ok
}

// ResetJenkinsBuildId reset all changes of the "jenkinsBuildId" field.
func (m *BuildMutation) ResetJenkinsBuildId() {
	m.jenkinsBuildId = nil
	m.addjenkinsBuildId = nil
	delete(m.clearedFields, build.FieldJenkinsBuildId)
}

// SetCreatedAt sets the createdAt field.
func (m *BuildMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *BuildMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *BuildMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *BuildMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *BuildMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *BuildMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetInstanceID sets the instance edge to Instance by id.
func (m *BuildMutation) SetInstanceID(id int) {
	m.instance = &id
}

// ClearInstance clears the instance edge to Instance.
func (m *BuildMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared returns if the edge instance was cleared.
func (m *BuildMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the instance id in the mutation.
func (m *BuildMutation) InstanceID() (id int, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the instance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) InstanceIDs() (ids []int) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance reset all changes of the "instance" edge.
func (m *BuildMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.tag != nil {
		fields = append(fields, build.FieldTag)
	}
	if m.name != nil {
		fields = append(fields, build.FieldName)
	}
	if m.status != nil {
		fields = append(fields, build.FieldStatus)
	}
	if m.commitId != nil {
		fields = append(fields, build.FieldCommitId)
	}
	if m.shortId != nil {
		fields = append(fields, build.FieldShortId)
	}
	if m.message != nil {
		fields = append(fields, build.FieldMessage)
	}
	if m.committerName != nil {
		fields = append(fields, build.FieldCommitterName)
	}
	if m.committedData != nil {
		fields = append(fields, build.FieldCommittedData)
	}
	if m.buildTime != nil {
		fields = append(fields, build.FieldBuildTime)
	}
	if m.jenkinsQueueId != nil {
		fields = append(fields, build.FieldJenkinsQueueId)
	}
	if m.jenkinsBuildId != nil {
		fields = append(fields, build.FieldJenkinsBuildId)
	}
	if m.createdAt != nil {
		fields = append(fields, build.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, build.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldTag:
		return m.Tag()
	case build.FieldName:
		return m.Name()
	case build.FieldStatus:
		return m.Status()
	case build.FieldCommitId:
		return m.CommitId()
	case build.FieldShortId:
		return m.ShortId()
	case build.FieldMessage:
		return m.Message()
	case build.FieldCommitterName:
		return m.CommitterName()
	case build.FieldCommittedData:
		return m.CommittedData()
	case build.FieldBuildTime:
		return m.BuildTime()
	case build.FieldJenkinsQueueId:
		return m.JenkinsQueueId()
	case build.FieldJenkinsBuildId:
		return m.JenkinsBuildId()
	case build.FieldCreatedAt:
		return m.CreatedAt()
	case build.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldTag:
		return m.OldTag(ctx)
	case build.FieldName:
		return m.OldName(ctx)
	case build.FieldStatus:
		return m.OldStatus(ctx)
	case build.FieldCommitId:
		return m.OldCommitId(ctx)
	case build.FieldShortId:
		return m.OldShortId(ctx)
	case build.FieldMessage:
		return m.OldMessage(ctx)
	case build.FieldCommitterName:
		return m.OldCommitterName(ctx)
	case build.FieldCommittedData:
		return m.OldCommittedData(ctx)
	case build.FieldBuildTime:
		return m.OldBuildTime(ctx)
	case build.FieldJenkinsQueueId:
		return m.OldJenkinsQueueId(ctx)
	case build.FieldJenkinsBuildId:
		return m.OldJenkinsBuildId(ctx)
	case build.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case build.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case build.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case build.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case build.FieldCommitId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitId(v)
		return nil
	case build.FieldShortId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortId(v)
		return nil
	case build.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case build.FieldCommitterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitterName(v)
		return nil
	case build.FieldCommittedData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommittedData(v)
		return nil
	case build.FieldBuildTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildTime(v)
		return nil
	case build.FieldJenkinsQueueId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJenkinsQueueId(v)
		return nil
	case build.FieldJenkinsBuildId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJenkinsBuildId(v)
		return nil
	case build.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case build.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BuildMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, build.FieldStatus)
	}
	if m.addjenkinsQueueId != nil {
		fields = append(fields, build.FieldJenkinsQueueId)
	}
	if m.addjenkinsBuildId != nil {
		fields = append(fields, build.FieldJenkinsBuildId)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case build.FieldStatus:
		return m.AddedStatus()
	case build.FieldJenkinsQueueId:
		return m.AddedJenkinsQueueId()
	case build.FieldJenkinsBuildId:
		return m.AddedJenkinsBuildId()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case build.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case build.FieldJenkinsQueueId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJenkinsQueueId(v)
		return nil
	case build.FieldJenkinsBuildId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJenkinsBuildId(v)
		return nil
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BuildMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(build.FieldJenkinsBuildId) {
		fields = append(fields, build.FieldJenkinsBuildId)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	switch name {
	case build.FieldJenkinsBuildId:
		m.ClearJenkinsBuildId()
		return nil
	}
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldTag:
		m.ResetTag()
		return nil
	case build.FieldName:
		m.ResetName()
		return nil
	case build.FieldStatus:
		m.ResetStatus()
		return nil
	case build.FieldCommitId:
		m.ResetCommitId()
		return nil
	case build.FieldShortId:
		m.ResetShortId()
		return nil
	case build.FieldMessage:
		m.ResetMessage()
		return nil
	case build.FieldCommitterName:
		m.ResetCommitterName()
		return nil
	case build.FieldCommittedData:
		m.ResetCommittedData()
		return nil
	case build.FieldBuildTime:
		m.ResetBuildTime()
		return nil
	case build.FieldJenkinsQueueId:
		m.ResetJenkinsQueueId()
		return nil
	case build.FieldJenkinsBuildId:
		m.ResetJenkinsBuildId()
		return nil
	case build.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case build.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instance != nil {
		edges = append(edges, build.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstance {
		edges = append(edges, build.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	case build.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// HelmConfigMutation represents an operation that mutate the HelmConfigs
// nodes in the graph.
type HelmConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int
	chartVersion  *string
	active        *string
	enableService *bool
	serviceType   *string
	nodePort      *int
	addnodePort   *int
	limitMem      *string
	limitCPU      *string
	reqCPU        *string
	reqMem        *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*HelmConfig, error)
	predicates    []predicate.HelmConfig
}

var _ ent.Mutation = (*HelmConfigMutation)(nil)

// helmconfigOption allows to manage the mutation configuration using functional options.
type helmconfigOption func(*HelmConfigMutation)

// newHelmConfigMutation creates new mutation for $n.Name.
func newHelmConfigMutation(c config, op Op, opts ...helmconfigOption) *HelmConfigMutation {
	m := &HelmConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeHelmConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHelmConfigID sets the id field of the mutation.
func withHelmConfigID(id int) helmconfigOption {
	return func(m *HelmConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *HelmConfig
		)
		m.oldValue = func(ctx context.Context) (*HelmConfig, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HelmConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHelmConfig sets the old HelmConfig of the mutation.
func withHelmConfig(node *HelmConfig) helmconfigOption {
	return func(m *HelmConfigMutation) {
		m.oldValue = func(context.Context) (*HelmConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HelmConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HelmConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HelmConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetChartVersion sets the chartVersion field.
func (m *HelmConfigMutation) SetChartVersion(s string) {
	m.chartVersion = &s
}

// ChartVersion returns the chartVersion value in the mutation.
func (m *HelmConfigMutation) ChartVersion() (r string, exists bool) {
	v := m.chartVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldChartVersion returns the old chartVersion value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldChartVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChartVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChartVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChartVersion: %w", err)
	}
	return oldValue.ChartVersion, nil
}

// ResetChartVersion reset all changes of the "chartVersion" field.
func (m *HelmConfigMutation) ResetChartVersion() {
	m.chartVersion = nil
}

// SetActive sets the active field.
func (m *HelmConfigMutation) SetActive(s string) {
	m.active = &s
}

// Active returns the active value in the mutation.
func (m *HelmConfigMutation) Active() (r string, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old active value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldActive(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActive is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive reset all changes of the "active" field.
func (m *HelmConfigMutation) ResetActive() {
	m.active = nil
}

// SetEnableService sets the enableService field.
func (m *HelmConfigMutation) SetEnableService(b bool) {
	m.enableService = &b
}

// EnableService returns the enableService value in the mutation.
func (m *HelmConfigMutation) EnableService() (r bool, exists bool) {
	v := m.enableService
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableService returns the old enableService value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldEnableService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnableService is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnableService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableService: %w", err)
	}
	return oldValue.EnableService, nil
}

// ResetEnableService reset all changes of the "enableService" field.
func (m *HelmConfigMutation) ResetEnableService() {
	m.enableService = nil
}

// SetServiceType sets the serviceType field.
func (m *HelmConfigMutation) SetServiceType(s string) {
	m.serviceType = &s
}

// ServiceType returns the serviceType value in the mutation.
func (m *HelmConfigMutation) ServiceType() (r string, exists bool) {
	v := m.serviceType
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old serviceType value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldServiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ResetServiceType reset all changes of the "serviceType" field.
func (m *HelmConfigMutation) ResetServiceType() {
	m.serviceType = nil
}

// SetNodePort sets the nodePort field.
func (m *HelmConfigMutation) SetNodePort(i int) {
	m.nodePort = &i
	m.addnodePort = nil
}

// NodePort returns the nodePort value in the mutation.
func (m *HelmConfigMutation) NodePort() (r int, exists bool) {
	v := m.nodePort
	if v == nil {
		return
	}
	return *v, true
}

// OldNodePort returns the old nodePort value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldNodePort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodePort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodePort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodePort: %w", err)
	}
	return oldValue.NodePort, nil
}

// AddNodePort adds i to nodePort.
func (m *HelmConfigMutation) AddNodePort(i int) {
	if m.addnodePort != nil {
		*m.addnodePort += i
	} else {
		m.addnodePort = &i
	}
}

// AddedNodePort returns the value that was added to the nodePort field in this mutation.
func (m *HelmConfigMutation) AddedNodePort() (r int, exists bool) {
	v := m.addnodePort
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodePort reset all changes of the "nodePort" field.
func (m *HelmConfigMutation) ResetNodePort() {
	m.nodePort = nil
	m.addnodePort = nil
}

// SetLimitMem sets the limitMem field.
func (m *HelmConfigMutation) SetLimitMem(s string) {
	m.limitMem = &s
}

// LimitMem returns the limitMem value in the mutation.
func (m *HelmConfigMutation) LimitMem() (r string, exists bool) {
	v := m.limitMem
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitMem returns the old limitMem value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldLimitMem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLimitMem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLimitMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitMem: %w", err)
	}
	return oldValue.LimitMem, nil
}

// ResetLimitMem reset all changes of the "limitMem" field.
func (m *HelmConfigMutation) ResetLimitMem() {
	m.limitMem = nil
}

// SetLimitCPU sets the limitCPU field.
func (m *HelmConfigMutation) SetLimitCPU(s string) {
	m.limitCPU = &s
}

// LimitCPU returns the limitCPU value in the mutation.
func (m *HelmConfigMutation) LimitCPU() (r string, exists bool) {
	v := m.limitCPU
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitCPU returns the old limitCPU value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldLimitCPU(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLimitCPU is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLimitCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitCPU: %w", err)
	}
	return oldValue.LimitCPU, nil
}

// ResetLimitCPU reset all changes of the "limitCPU" field.
func (m *HelmConfigMutation) ResetLimitCPU() {
	m.limitCPU = nil
}

// SetReqCPU sets the reqCPU field.
func (m *HelmConfigMutation) SetReqCPU(s string) {
	m.reqCPU = &s
}

// ReqCPU returns the reqCPU value in the mutation.
func (m *HelmConfigMutation) ReqCPU() (r string, exists bool) {
	v := m.reqCPU
	if v == nil {
		return
	}
	return *v, true
}

// OldReqCPU returns the old reqCPU value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldReqCPU(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReqCPU is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReqCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqCPU: %w", err)
	}
	return oldValue.ReqCPU, nil
}

// ResetReqCPU reset all changes of the "reqCPU" field.
func (m *HelmConfigMutation) ResetReqCPU() {
	m.reqCPU = nil
}

// SetReqMem sets the reqMem field.
func (m *HelmConfigMutation) SetReqMem(s string) {
	m.reqMem = &s
}

// ReqMem returns the reqMem value in the mutation.
func (m *HelmConfigMutation) ReqMem() (r string, exists bool) {
	v := m.reqMem
	if v == nil {
		return
	}
	return *v, true
}

// OldReqMem returns the old reqMem value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldReqMem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReqMem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReqMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqMem: %w", err)
	}
	return oldValue.ReqMem, nil
}

// ResetReqMem reset all changes of the "reqMem" field.
func (m *HelmConfigMutation) ResetReqMem() {
	m.reqMem = nil
}

// SetCreatedAt sets the createdAt field.
func (m *HelmConfigMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *HelmConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *HelmConfigMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *HelmConfigMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *HelmConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the HelmConfig.
// If the HelmConfig object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HelmConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *HelmConfigMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// Op returns the operation name.
func (m *HelmConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HelmConfig).
func (m *HelmConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HelmConfigMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.chartVersion != nil {
		fields = append(fields, helmconfig.FieldChartVersion)
	}
	if m.active != nil {
		fields = append(fields, helmconfig.FieldActive)
	}
	if m.enableService != nil {
		fields = append(fields, helmconfig.FieldEnableService)
	}
	if m.serviceType != nil {
		fields = append(fields, helmconfig.FieldServiceType)
	}
	if m.nodePort != nil {
		fields = append(fields, helmconfig.FieldNodePort)
	}
	if m.limitMem != nil {
		fields = append(fields, helmconfig.FieldLimitMem)
	}
	if m.limitCPU != nil {
		fields = append(fields, helmconfig.FieldLimitCPU)
	}
	if m.reqCPU != nil {
		fields = append(fields, helmconfig.FieldReqCPU)
	}
	if m.reqMem != nil {
		fields = append(fields, helmconfig.FieldReqMem)
	}
	if m.createdAt != nil {
		fields = append(fields, helmconfig.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, helmconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HelmConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case helmconfig.FieldChartVersion:
		return m.ChartVersion()
	case helmconfig.FieldActive:
		return m.Active()
	case helmconfig.FieldEnableService:
		return m.EnableService()
	case helmconfig.FieldServiceType:
		return m.ServiceType()
	case helmconfig.FieldNodePort:
		return m.NodePort()
	case helmconfig.FieldLimitMem:
		return m.LimitMem()
	case helmconfig.FieldLimitCPU:
		return m.LimitCPU()
	case helmconfig.FieldReqCPU:
		return m.ReqCPU()
	case helmconfig.FieldReqMem:
		return m.ReqMem()
	case helmconfig.FieldCreatedAt:
		return m.CreatedAt()
	case helmconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HelmConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case helmconfig.FieldChartVersion:
		return m.OldChartVersion(ctx)
	case helmconfig.FieldActive:
		return m.OldActive(ctx)
	case helmconfig.FieldEnableService:
		return m.OldEnableService(ctx)
	case helmconfig.FieldServiceType:
		return m.OldServiceType(ctx)
	case helmconfig.FieldNodePort:
		return m.OldNodePort(ctx)
	case helmconfig.FieldLimitMem:
		return m.OldLimitMem(ctx)
	case helmconfig.FieldLimitCPU:
		return m.OldLimitCPU(ctx)
	case helmconfig.FieldReqCPU:
		return m.OldReqCPU(ctx)
	case helmconfig.FieldReqMem:
		return m.OldReqMem(ctx)
	case helmconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case helmconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown HelmConfig field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HelmConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case helmconfig.FieldChartVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChartVersion(v)
		return nil
	case helmconfig.FieldActive:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case helmconfig.FieldEnableService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableService(v)
		return nil
	case helmconfig.FieldServiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case helmconfig.FieldNodePort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodePort(v)
		return nil
	case helmconfig.FieldLimitMem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitMem(v)
		return nil
	case helmconfig.FieldLimitCPU:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitCPU(v)
		return nil
	case helmconfig.FieldReqCPU:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqCPU(v)
		return nil
	case helmconfig.FieldReqMem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqMem(v)
		return nil
	case helmconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case helmconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown HelmConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HelmConfigMutation) AddedFields() []string {
	var fields []string
	if m.addnodePort != nil {
		fields = append(fields, helmconfig.FieldNodePort)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HelmConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case helmconfig.FieldNodePort:
		return m.AddedNodePort()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HelmConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case helmconfig.FieldNodePort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodePort(v)
		return nil
	}
	return fmt.Errorf("unknown HelmConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HelmConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HelmConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HelmConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HelmConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HelmConfigMutation) ResetField(name string) error {
	switch name {
	case helmconfig.FieldChartVersion:
		m.ResetChartVersion()
		return nil
	case helmconfig.FieldActive:
		m.ResetActive()
		return nil
	case helmconfig.FieldEnableService:
		m.ResetEnableService()
		return nil
	case helmconfig.FieldServiceType:
		m.ResetServiceType()
		return nil
	case helmconfig.FieldNodePort:
		m.ResetNodePort()
		return nil
	case helmconfig.FieldLimitMem:
		m.ResetLimitMem()
		return nil
	case helmconfig.FieldLimitCPU:
		m.ResetLimitCPU()
		return nil
	case helmconfig.FieldReqCPU:
		m.ResetReqCPU()
		return nil
	case helmconfig.FieldReqMem:
		m.ResetReqMem()
		return nil
	case helmconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case helmconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown HelmConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HelmConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HelmConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HelmConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HelmConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HelmConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HelmConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HelmConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HelmConfig unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HelmConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HelmConfig edge %s", name)
}

// InstanceMutation represents an operation that mutate the Instances
// nodes in the graph.
type InstanceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	applicationId      *int
	addapplicationId   *int
	createdAt          *time.Time
	updatedAt          *time.Time
	clearedFields      map[string]struct{}
	application        *int
	clearedapplication bool
	builds             map[int]struct{}
	removedbuilds      map[int]struct{}
	clearedbuilds      bool
	_config            *int
	cleared_config     bool
	done               bool
	oldValue           func(context.Context) (*Instance, error)
	predicates         []predicate.Instance
}

var _ ent.Mutation = (*InstanceMutation)(nil)

// instanceOption allows to manage the mutation configuration using functional options.
type instanceOption func(*InstanceMutation)

// newInstanceMutation creates new mutation for $n.Name.
func newInstanceMutation(c config, op Op, opts ...instanceOption) *InstanceMutation {
	m := &InstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceID sets the id field of the mutation.
func withInstanceID(id int) instanceOption {
	return func(m *InstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Instance
		)
		m.oldValue = func(ctx context.Context) (*Instance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstance sets the old Instance of the mutation.
func withInstance(node *Instance) instanceOption {
	return func(m *InstanceMutation) {
		m.oldValue = func(context.Context) (*Instance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *InstanceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *InstanceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Instance.
// If the Instance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstanceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *InstanceMutation) ResetName() {
	m.name = nil
}

// SetApplicationId sets the applicationId field.
func (m *InstanceMutation) SetApplicationId(i int) {
	m.applicationId = &i
	m.addapplicationId = nil
}

// ApplicationId returns the applicationId value in the mutation.
func (m *InstanceMutation) ApplicationId() (r int, exists bool) {
	v := m.applicationId
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationId returns the old applicationId value of the Instance.
// If the Instance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstanceMutation) OldApplicationId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplicationId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplicationId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationId: %w", err)
	}
	return oldValue.ApplicationId, nil
}

// AddApplicationId adds i to applicationId.
func (m *InstanceMutation) AddApplicationId(i int) {
	if m.addapplicationId != nil {
		*m.addapplicationId += i
	} else {
		m.addapplicationId = &i
	}
}

// AddedApplicationId returns the value that was added to the applicationId field in this mutation.
func (m *InstanceMutation) AddedApplicationId() (r int, exists bool) {
	v := m.addapplicationId
	if v == nil {
		return
	}
	return *v, true
}

// ResetApplicationId reset all changes of the "applicationId" field.
func (m *InstanceMutation) ResetApplicationId() {
	m.applicationId = nil
	m.addapplicationId = nil
}

// SetCreatedAt sets the createdAt field.
func (m *InstanceMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *InstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Instance.
// If the Instance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *InstanceMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *InstanceMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *InstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Instance.
// If the Instance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *InstanceMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetApplicationID sets the application edge to Application by id.
func (m *InstanceMutation) SetApplicationID(id int) {
	m.application = &id
}

// ClearApplication clears the application edge to Application.
func (m *InstanceMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared returns if the edge application was cleared.
func (m *InstanceMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationID returns the application id in the mutation.
func (m *InstanceMutation) ApplicationID() (id int, exists bool) {
	if m.application != nil {
		return *m.application, true
	}
	return
}

// ApplicationIDs returns the application ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) ApplicationIDs() (ids []int) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication reset all changes of the "application" edge.
func (m *InstanceMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// AddBuildIDs adds the builds edge to Build by ids.
func (m *InstanceMutation) AddBuildIDs(ids ...int) {
	if m.builds == nil {
		m.builds = make(map[int]struct{})
	}
	for i := range ids {
		m.builds[ids[i]] = struct{}{}
	}
}

// ClearBuilds clears the builds edge to Build.
func (m *InstanceMutation) ClearBuilds() {
	m.clearedbuilds = true
}

// BuildsCleared returns if the edge builds was cleared.
func (m *InstanceMutation) BuildsCleared() bool {
	return m.clearedbuilds
}

// RemoveBuildIDs removes the builds edge to Build by ids.
func (m *InstanceMutation) RemoveBuildIDs(ids ...int) {
	if m.removedbuilds == nil {
		m.removedbuilds = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbuilds[ids[i]] = struct{}{}
	}
}

// RemovedBuilds returns the removed ids of builds.
func (m *InstanceMutation) RemovedBuildsIDs() (ids []int) {
	for id := range m.removedbuilds {
		ids = append(ids, id)
	}
	return
}

// BuildsIDs returns the builds ids in the mutation.
func (m *InstanceMutation) BuildsIDs() (ids []int) {
	for id := range m.builds {
		ids = append(ids, id)
	}
	return
}

// ResetBuilds reset all changes of the "builds" edge.
func (m *InstanceMutation) ResetBuilds() {
	m.builds = nil
	m.clearedbuilds = false
	m.removedbuilds = nil
}

// SetConfigID sets the config edge to HelmConfig by id.
func (m *InstanceMutation) SetConfigID(id int) {
	m._config = &id
}

// ClearConfig clears the config edge to HelmConfig.
func (m *InstanceMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared returns if the edge config was cleared.
func (m *InstanceMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the config id in the mutation.
func (m *InstanceMutation) ConfigID() (id int, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the config ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) ConfigIDs() (ids []int) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig reset all changes of the "config" edge.
func (m *InstanceMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// Op returns the operation name.
func (m *InstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Instance).
func (m *InstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstanceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, instance.FieldName)
	}
	if m.applicationId != nil {
		fields = append(fields, instance.FieldApplicationId)
	}
	if m.createdAt != nil {
		fields = append(fields, instance.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, instance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instance.FieldName:
		return m.Name()
	case instance.FieldApplicationId:
		return m.ApplicationId()
	case instance.FieldCreatedAt:
		return m.CreatedAt()
	case instance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instance.FieldName:
		return m.OldName(ctx)
	case instance.FieldApplicationId:
		return m.OldApplicationId(ctx)
	case instance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case instance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Instance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instance.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case instance.FieldApplicationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationId(v)
		return nil
	case instance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case instance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstanceMutation) AddedFields() []string {
	var fields []string
	if m.addapplicationId != nil {
		fields = append(fields, instance.FieldApplicationId)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instance.FieldApplicationId:
		return m.AddedApplicationId()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instance.FieldApplicationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApplicationId(v)
		return nil
	}
	return fmt.Errorf("unknown Instance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Instance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstanceMutation) ResetField(name string) error {
	switch name {
	case instance.FieldName:
		m.ResetName()
		return nil
	case instance.FieldApplicationId:
		m.ResetApplicationId()
		return nil
	case instance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case instance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.application != nil {
		edges = append(edges, instance.EdgeApplication)
	}
	if m.builds != nil {
		edges = append(edges, instance.EdgeBuilds)
	}
	if m._config != nil {
		edges = append(edges, instance.EdgeConfig)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.builds))
		for id := range m.builds {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbuilds != nil {
		edges = append(edges, instance.EdgeBuilds)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.removedbuilds))
		for id := range m.removedbuilds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplication {
		edges = append(edges, instance.EdgeApplication)
	}
	if m.clearedbuilds {
		edges = append(edges, instance.EdgeBuilds)
	}
	if m.cleared_config {
		edges = append(edges, instance.EdgeConfig)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case instance.EdgeApplication:
		return m.clearedapplication
	case instance.EdgeBuilds:
		return m.clearedbuilds
	case instance.EdgeConfig:
		return m.cleared_config
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstanceMutation) ClearEdge(name string) error {
	switch name {
	case instance.EdgeApplication:
		m.ClearApplication()
		return nil
	case instance.EdgeConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Instance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstanceMutation) ResetEdge(name string) error {
	switch name {
	case instance.EdgeApplication:
		m.ResetApplication()
		return nil
	case instance.EdgeBuilds:
		m.ResetBuilds()
		return nil
	case instance.EdgeConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Instance edge %s", name)
}

// K8sClusterMutation represents an operation that mutate the K8sClusters
// nodes in the graph.
type K8sClusterMutation struct {
	config
	op                Op
	typ               string
	id                *int
	cluster           *string
	helmApi           *string
	accessToken       *string
	createdAt         *time.Time
	updatedAt         *time.Time
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*K8sCluster, error)
	predicates        []predicate.K8sCluster
}

var _ ent.Mutation = (*K8sClusterMutation)(nil)

// k8sclusterOption allows to manage the mutation configuration using functional options.
type k8sclusterOption func(*K8sClusterMutation)

// newK8sClusterMutation creates new mutation for $n.Name.
func newK8sClusterMutation(c config, op Op, opts ...k8sclusterOption) *K8sClusterMutation {
	m := &K8sClusterMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sCluster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sClusterID sets the id field of the mutation.
func withK8sClusterID(id int) k8sclusterOption {
	return func(m *K8sClusterMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sCluster
		)
		m.oldValue = func(ctx context.Context) (*K8sCluster, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sCluster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sCluster sets the old K8sCluster of the mutation.
func withK8sCluster(node *K8sCluster) k8sclusterOption {
	return func(m *K8sClusterMutation) {
		m.oldValue = func(context.Context) (*K8sCluster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sClusterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sClusterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *K8sClusterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCluster sets the cluster field.
func (m *K8sClusterMutation) SetCluster(s string) {
	m.cluster = &s
}

// Cluster returns the cluster value in the mutation.
func (m *K8sClusterMutation) Cluster() (r string, exists bool) {
	v := m.cluster
	if v == nil {
		return
	}
	return *v, true
}

// OldCluster returns the old cluster value of the K8sCluster.
// If the K8sCluster object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *K8sClusterMutation) OldCluster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCluster is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCluster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCluster: %w", err)
	}
	return oldValue.Cluster, nil
}

// ResetCluster reset all changes of the "cluster" field.
func (m *K8sClusterMutation) ResetCluster() {
	m.cluster = nil
}

// SetHelmApi sets the helmApi field.
func (m *K8sClusterMutation) SetHelmApi(s string) {
	m.helmApi = &s
}

// HelmApi returns the helmApi value in the mutation.
func (m *K8sClusterMutation) HelmApi() (r string, exists bool) {
	v := m.helmApi
	if v == nil {
		return
	}
	return *v, true
}

// OldHelmApi returns the old helmApi value of the K8sCluster.
// If the K8sCluster object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *K8sClusterMutation) OldHelmApi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHelmApi is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHelmApi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHelmApi: %w", err)
	}
	return oldValue.HelmApi, nil
}

// ResetHelmApi reset all changes of the "helmApi" field.
func (m *K8sClusterMutation) ResetHelmApi() {
	m.helmApi = nil
}

// SetAccessToken sets the accessToken field.
func (m *K8sClusterMutation) SetAccessToken(s string) {
	m.accessToken = &s
}

// AccessToken returns the accessToken value in the mutation.
func (m *K8sClusterMutation) AccessToken() (r string, exists bool) {
	v := m.accessToken
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old accessToken value of the K8sCluster.
// If the K8sCluster object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *K8sClusterMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessToken is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of accessToken.
func (m *K8sClusterMutation) ClearAccessToken() {
	m.accessToken = nil
	m.clearedFields[k8scluster.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the field accessToken was cleared in this mutation.
func (m *K8sClusterMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[k8scluster.FieldAccessToken]
	return ok
}

// ResetAccessToken reset all changes of the "accessToken" field.
func (m *K8sClusterMutation) ResetAccessToken() {
	m.accessToken = nil
	delete(m.clearedFields, k8scluster.FieldAccessToken)
}

// SetCreatedAt sets the createdAt field.
func (m *K8sClusterMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *K8sClusterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the K8sCluster.
// If the K8sCluster object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *K8sClusterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *K8sClusterMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *K8sClusterMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *K8sClusterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the K8sCluster.
// If the K8sCluster object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *K8sClusterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *K8sClusterMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddNamespaceIDs adds the namespaces edge to Namespace by ids.
func (m *K8sClusterMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the namespaces edge to Namespace.
func (m *K8sClusterMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared returns if the edge namespaces was cleared.
func (m *K8sClusterMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the namespaces edge to Namespace by ids.
func (m *K8sClusterMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed ids of namespaces.
func (m *K8sClusterMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the namespaces ids in the mutation.
func (m *K8sClusterMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces reset all changes of the "namespaces" edge.
func (m *K8sClusterMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Op returns the operation name.
func (m *K8sClusterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sCluster).
func (m *K8sClusterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *K8sClusterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.cluster != nil {
		fields = append(fields, k8scluster.FieldCluster)
	}
	if m.helmApi != nil {
		fields = append(fields, k8scluster.FieldHelmApi)
	}
	if m.accessToken != nil {
		fields = append(fields, k8scluster.FieldAccessToken)
	}
	if m.createdAt != nil {
		fields = append(fields, k8scluster.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, k8scluster.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *K8sClusterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8scluster.FieldCluster:
		return m.Cluster()
	case k8scluster.FieldHelmApi:
		return m.HelmApi()
	case k8scluster.FieldAccessToken:
		return m.AccessToken()
	case k8scluster.FieldCreatedAt:
		return m.CreatedAt()
	case k8scluster.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *K8sClusterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8scluster.FieldCluster:
		return m.OldCluster(ctx)
	case k8scluster.FieldHelmApi:
		return m.OldHelmApi(ctx)
	case k8scluster.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case k8scluster.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8scluster.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown K8sCluster field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *K8sClusterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8scluster.FieldCluster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCluster(v)
		return nil
	case k8scluster.FieldHelmApi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHelmApi(v)
		return nil
	case k8scluster.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case k8scluster.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8scluster.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown K8sCluster field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *K8sClusterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *K8sClusterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *K8sClusterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown K8sCluster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *K8sClusterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(k8scluster.FieldAccessToken) {
		fields = append(fields, k8scluster.FieldAccessToken)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *K8sClusterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sClusterMutation) ClearField(name string) error {
	switch name {
	case k8scluster.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	}
	return fmt.Errorf("unknown K8sCluster nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *K8sClusterMutation) ResetField(name string) error {
	switch name {
	case k8scluster.FieldCluster:
		m.ResetCluster()
		return nil
	case k8scluster.FieldHelmApi:
		m.ResetHelmApi()
		return nil
	case k8scluster.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case k8scluster.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8scluster.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown K8sCluster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *K8sClusterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, k8scluster.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *K8sClusterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case k8scluster.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *K8sClusterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, k8scluster.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *K8sClusterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case k8scluster.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *K8sClusterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, k8scluster.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *K8sClusterMutation) EdgeCleared(name string) bool {
	switch name {
	case k8scluster.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *K8sClusterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown K8sCluster unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *K8sClusterMutation) ResetEdge(name string) error {
	switch name {
	case k8scluster.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown K8sCluster edge %s", name)
}

// MenuMutation represents an operation that mutate the Menus
// nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_path           *string
	name            *string
	component       *string
	parentId        *int
	addparentId     *int
	redirect        *string
	weight          *int
	addweight       *int
	level           *int
	addlevel        *int
	title           *string
	icon            *string
	target          *string
	keepAlive       *bool
	show            *bool
	createdAt       *time.Time
	updatedAt       *time.Time
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	submenus        map[int]struct{}
	removedsubmenus map[int]struct{}
	clearedsubmenus bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows to manage the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for $n.Name.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the id field of the mutation.
func withMenuID(id int) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPath sets the path field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the path value in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old path value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath reset all changes of the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
}

// SetName sets the name field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetComponent sets the component field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the component value in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old component value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComponent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent reset all changes of the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
}

// SetParentId sets the parentId field.
func (m *MenuMutation) SetParentId(i int) {
	m.parentId = &i
	m.addparentId = nil
}

// ParentId returns the parentId value in the mutation.
func (m *MenuMutation) ParentId() (r int, exists bool) {
	v := m.parentId
	if v == nil {
		return
	}
	return *v, true
}

// OldParentId returns the old parentId value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldParentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentId: %w", err)
	}
	return oldValue.ParentId, nil
}

// AddParentId adds i to parentId.
func (m *MenuMutation) AddParentId(i int) {
	if m.addparentId != nil {
		*m.addparentId += i
	} else {
		m.addparentId = &i
	}
}

// AddedParentId returns the value that was added to the parentId field in this mutation.
func (m *MenuMutation) AddedParentId() (r int, exists bool) {
	v := m.addparentId
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentId reset all changes of the "parentId" field.
func (m *MenuMutation) ResetParentId() {
	m.parentId = nil
	m.addparentId = nil
}

// SetRedirect sets the redirect field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the redirect value in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old redirect value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRedirect is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of redirect.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the field redirect was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect reset all changes of the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetWeight sets the weight field.
func (m *MenuMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *MenuMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *MenuMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *MenuMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of weight.
func (m *MenuMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[menu.FieldWeight] = struct{}{}
}

// WeightCleared returns if the field weight was cleared in this mutation.
func (m *MenuMutation) WeightCleared() bool {
	_, ok := m.clearedFields[menu.FieldWeight]
	return ok
}

// ResetWeight reset all changes of the "weight" field.
func (m *MenuMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, menu.FieldWeight)
}

// SetLevel sets the level field.
func (m *MenuMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the level value in the mutation.
func (m *MenuMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old level value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to level.
func (m *MenuMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the level field in this mutation.
func (m *MenuMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel reset all changes of the "level" field.
func (m *MenuMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetTitle sets the title field.
func (m *MenuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *MenuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of title.
func (m *MenuMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[menu.FieldTitle] = struct{}{}
}

// TitleCleared returns if the field title was cleared in this mutation.
func (m *MenuMutation) TitleCleared() bool {
	_, ok := m.clearedFields[menu.FieldTitle]
	return ok
}

// ResetTitle reset all changes of the "title" field.
func (m *MenuMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, menu.FieldTitle)
}

// SetIcon sets the icon field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the icon value in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old icon value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIcon is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of icon.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the field icon was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon reset all changes of the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetTarget sets the target field.
func (m *MenuMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the target value in the mutation.
func (m *MenuMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old target value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTarget is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ClearTarget clears the value of target.
func (m *MenuMutation) ClearTarget() {
	m.target = nil
	m.clearedFields[menu.FieldTarget] = struct{}{}
}

// TargetCleared returns if the field target was cleared in this mutation.
func (m *MenuMutation) TargetCleared() bool {
	_, ok := m.clearedFields[menu.FieldTarget]
	return ok
}

// ResetTarget reset all changes of the "target" field.
func (m *MenuMutation) ResetTarget() {
	m.target = nil
	delete(m.clearedFields, menu.FieldTarget)
}

// SetKeepAlive sets the keepAlive field.
func (m *MenuMutation) SetKeepAlive(b bool) {
	m.keepAlive = &b
}

// KeepAlive returns the keepAlive value in the mutation.
func (m *MenuMutation) KeepAlive() (r bool, exists bool) {
	v := m.keepAlive
	if v == nil {
		return
	}
	return *v, true
}

// OldKeepAlive returns the old keepAlive value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldKeepAlive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeepAlive is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeepAlive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeepAlive: %w", err)
	}
	return oldValue.KeepAlive, nil
}

// ResetKeepAlive reset all changes of the "keepAlive" field.
func (m *MenuMutation) ResetKeepAlive() {
	m.keepAlive = nil
}

// SetShow sets the show field.
func (m *MenuMutation) SetShow(b bool) {
	m.show = &b
}

// Show returns the show value in the mutation.
func (m *MenuMutation) Show() (r bool, exists bool) {
	v := m.show
	if v == nil {
		return
	}
	return *v, true
}

// OldShow returns the old show value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldShow(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShow is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShow: %w", err)
	}
	return oldValue.Show, nil
}

// ClearShow clears the value of show.
func (m *MenuMutation) ClearShow() {
	m.show = nil
	m.clearedFields[menu.FieldShow] = struct{}{}
}

// ShowCleared returns if the field show was cleared in this mutation.
func (m *MenuMutation) ShowCleared() bool {
	_, ok := m.clearedFields[menu.FieldShow]
	return ok
}

// ResetShow reset all changes of the "show" field.
func (m *MenuMutation) ResetShow() {
	m.show = nil
	delete(m.clearedFields, menu.FieldShow)
}

// SetCreatedAt sets the createdAt field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetParentID sets the parent edge to Menu by id.
func (m *MenuMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Menu.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *MenuMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddSubmenuIDs adds the submenus edge to Menu by ids.
func (m *MenuMutation) AddSubmenuIDs(ids ...int) {
	if m.submenus == nil {
		m.submenus = make(map[int]struct{})
	}
	for i := range ids {
		m.submenus[ids[i]] = struct{}{}
	}
}

// ClearSubmenus clears the submenus edge to Menu.
func (m *MenuMutation) ClearSubmenus() {
	m.clearedsubmenus = true
}

// SubmenusCleared returns if the edge submenus was cleared.
func (m *MenuMutation) SubmenusCleared() bool {
	return m.clearedsubmenus
}

// RemoveSubmenuIDs removes the submenus edge to Menu by ids.
func (m *MenuMutation) RemoveSubmenuIDs(ids ...int) {
	if m.removedsubmenus == nil {
		m.removedsubmenus = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubmenus[ids[i]] = struct{}{}
	}
}

// RemovedSubmenus returns the removed ids of submenus.
func (m *MenuMutation) RemovedSubmenusIDs() (ids []int) {
	for id := range m.removedsubmenus {
		ids = append(ids, id)
	}
	return
}

// SubmenusIDs returns the submenus ids in the mutation.
func (m *MenuMutation) SubmenusIDs() (ids []int) {
	for id := range m.submenus {
		ids = append(ids, id)
	}
	return
}

// ResetSubmenus reset all changes of the "submenus" edge.
func (m *MenuMutation) ResetSubmenus() {
	m.submenus = nil
	m.clearedsubmenus = false
	m.removedsubmenus = nil
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.parentId != nil {
		fields = append(fields, menu.FieldParentId)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.weight != nil {
		fields = append(fields, menu.FieldWeight)
	}
	if m.level != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.title != nil {
		fields = append(fields, menu.FieldTitle)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.target != nil {
		fields = append(fields, menu.FieldTarget)
	}
	if m.keepAlive != nil {
		fields = append(fields, menu.FieldKeepAlive)
	}
	if m.show != nil {
		fields = append(fields, menu.FieldShow)
	}
	if m.createdAt != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldParentId:
		return m.ParentId()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldWeight:
		return m.Weight()
	case menu.FieldLevel:
		return m.Level()
	case menu.FieldTitle:
		return m.Title()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldTarget:
		return m.Target()
	case menu.FieldKeepAlive:
		return m.KeepAlive()
	case menu.FieldShow:
		return m.Show()
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldParentId:
		return m.OldParentId(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldWeight:
		return m.OldWeight(ctx)
	case menu.FieldLevel:
		return m.OldLevel(ctx)
	case menu.FieldTitle:
		return m.OldTitle(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldTarget:
		return m.OldTarget(ctx)
	case menu.FieldKeepAlive:
		return m.OldKeepAlive(ctx)
	case menu.FieldShow:
		return m.OldShow(ctx)
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldParentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentId(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case menu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case menu.FieldKeepAlive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeepAlive(v)
		return nil
	case menu.FieldShow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShow(v)
		return nil
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addparentId != nil {
		fields = append(fields, menu.FieldParentId)
	}
	if m.addweight != nil {
		fields = append(fields, menu.FieldWeight)
	}
	if m.addlevel != nil {
		fields = append(fields, menu.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldParentId:
		return m.AddedParentId()
	case menu.FieldWeight:
		return m.AddedWeight()
	case menu.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldParentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentId(v)
		return nil
	case menu.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldWeight) {
		fields = append(fields, menu.FieldWeight)
	}
	if m.FieldCleared(menu.FieldTitle) {
		fields = append(fields, menu.FieldTitle)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldTarget) {
		fields = append(fields, menu.FieldTarget)
	}
	if m.FieldCleared(menu.FieldShow) {
		fields = append(fields, menu.FieldShow)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldWeight:
		m.ClearWeight()
		return nil
	case menu.FieldTitle:
		m.ClearTitle()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldTarget:
		m.ClearTarget()
		return nil
	case menu.FieldShow:
		m.ClearShow()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldParentId:
		m.ResetParentId()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldWeight:
		m.ResetWeight()
		return nil
	case menu.FieldLevel:
		m.ResetLevel()
		return nil
	case menu.FieldTitle:
		m.ResetTitle()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldTarget:
		m.ResetTarget()
		return nil
	case menu.FieldKeepAlive:
		m.ResetKeepAlive()
		return nil
	case menu.FieldShow:
		m.ResetShow()
		return nil
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.submenus != nil {
		edges = append(edges, menu.EdgeSubmenus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeSubmenus:
		ids := make([]ent.Value, 0, len(m.submenus))
		for id := range m.submenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubmenus != nil {
		edges = append(edges, menu.EdgeSubmenus)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeSubmenus:
		ids := make([]ent.Value, 0, len(m.removedsubmenus))
		for id := range m.removedsubmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedsubmenus {
		edges = append(edges, menu.EdgeSubmenus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeSubmenus:
		return m.clearedsubmenus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeSubmenus:
		m.ResetSubmenus()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// NamespaceMutation represents an operation that mutate the Namespaces
// nodes in the graph.
type NamespaceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	dockerRepo          *string
	repoNamespace       *string
	active              *string
	createdAt           *time.Time
	updatedAt           *time.Time
	clearedFields       map[string]struct{}
	cluster             *int
	clearedcluster      bool
	applications        map[int]struct{}
	removedapplications map[int]struct{}
	clearedapplications bool
	done                bool
	oldValue            func(context.Context) (*Namespace, error)
	predicates          []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows to manage the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for $n.Name.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the id field of the mutation.
func withNamespaceID(id int) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Namespace.
// If the Namespace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// SetDockerRepo sets the dockerRepo field.
func (m *NamespaceMutation) SetDockerRepo(s string) {
	m.dockerRepo = &s
}

// DockerRepo returns the dockerRepo value in the mutation.
func (m *NamespaceMutation) DockerRepo() (r string, exists bool) {
	v := m.dockerRepo
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerRepo returns the old dockerRepo value of the Namespace.
// If the Namespace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NamespaceMutation) OldDockerRepo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDockerRepo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDockerRepo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerRepo: %w", err)
	}
	return oldValue.DockerRepo, nil
}

// ResetDockerRepo reset all changes of the "dockerRepo" field.
func (m *NamespaceMutation) ResetDockerRepo() {
	m.dockerRepo = nil
}

// SetRepoNamespace sets the repoNamespace field.
func (m *NamespaceMutation) SetRepoNamespace(s string) {
	m.repoNamespace = &s
}

// RepoNamespace returns the repoNamespace value in the mutation.
func (m *NamespaceMutation) RepoNamespace() (r string, exists bool) {
	v := m.repoNamespace
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoNamespace returns the old repoNamespace value of the Namespace.
// If the Namespace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NamespaceMutation) OldRepoNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRepoNamespace is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRepoNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoNamespace: %w", err)
	}
	return oldValue.RepoNamespace, nil
}

// ResetRepoNamespace reset all changes of the "repoNamespace" field.
func (m *NamespaceMutation) ResetRepoNamespace() {
	m.repoNamespace = nil
}

// SetActive sets the active field.
func (m *NamespaceMutation) SetActive(s string) {
	m.active = &s
}

// Active returns the active value in the mutation.
func (m *NamespaceMutation) Active() (r string, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old active value of the Namespace.
// If the Namespace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NamespaceMutation) OldActive(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActive is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive reset all changes of the "active" field.
func (m *NamespaceMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the createdAt field.
func (m *NamespaceMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *NamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Namespace.
// If the Namespace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *NamespaceMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *NamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *NamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Namespace.
// If the Namespace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *NamespaceMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetClusterID sets the cluster edge to K8sCluster by id.
func (m *NamespaceMutation) SetClusterID(id int) {
	m.cluster = &id
}

// ClearCluster clears the cluster edge to K8sCluster.
func (m *NamespaceMutation) ClearCluster() {
	m.clearedcluster = true
}

// ClusterCleared returns if the edge cluster was cleared.
func (m *NamespaceMutation) ClusterCleared() bool {
	return m.clearedcluster
}

// ClusterID returns the cluster id in the mutation.
func (m *NamespaceMutation) ClusterID() (id int, exists bool) {
	if m.cluster != nil {
		return *m.cluster, true
	}
	return
}

// ClusterIDs returns the cluster ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClusterID instead. It exists only for internal usage by the builders.
func (m *NamespaceMutation) ClusterIDs() (ids []int) {
	if id := m.cluster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCluster reset all changes of the "cluster" edge.
func (m *NamespaceMutation) ResetCluster() {
	m.cluster = nil
	m.clearedcluster = false
}

// AddApplicationIDs adds the applications edge to Application by ids.
func (m *NamespaceMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the applications edge to Application.
func (m *NamespaceMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared returns if the edge applications was cleared.
func (m *NamespaceMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the applications edge to Application by ids.
func (m *NamespaceMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed ids of applications.
func (m *NamespaceMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the applications ids in the mutation.
func (m *NamespaceMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications reset all changes of the "applications" edge.
func (m *NamespaceMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	if m.dockerRepo != nil {
		fields = append(fields, namespace.FieldDockerRepo)
	}
	if m.repoNamespace != nil {
		fields = append(fields, namespace.FieldRepoNamespace)
	}
	if m.active != nil {
		fields = append(fields, namespace.FieldActive)
	}
	if m.createdAt != nil {
		fields = append(fields, namespace.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, namespace.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldName:
		return m.Name()
	case namespace.FieldDockerRepo:
		return m.DockerRepo()
	case namespace.FieldRepoNamespace:
		return m.RepoNamespace()
	case namespace.FieldActive:
		return m.Active()
	case namespace.FieldCreatedAt:
		return m.CreatedAt()
	case namespace.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldName:
		return m.OldName(ctx)
	case namespace.FieldDockerRepo:
		return m.OldDockerRepo(ctx)
	case namespace.FieldRepoNamespace:
		return m.OldRepoNamespace(ctx)
	case namespace.FieldActive:
		return m.OldActive(ctx)
	case namespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case namespace.FieldDockerRepo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerRepo(v)
		return nil
	case namespace.FieldRepoNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoNamespace(v)
		return nil
	case namespace.FieldActive:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case namespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldName:
		m.ResetName()
		return nil
	case namespace.FieldDockerRepo:
		m.ResetDockerRepo()
		return nil
	case namespace.FieldRepoNamespace:
		m.ResetRepoNamespace()
		return nil
	case namespace.FieldActive:
		m.ResetActive()
		return nil
	case namespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cluster != nil {
		edges = append(edges, namespace.EdgeCluster)
	}
	if m.applications != nil {
		edges = append(edges, namespace.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeCluster:
		if id := m.cluster; id != nil {
			return []ent.Value{*id}
		}
	case namespace.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapplications != nil {
		edges = append(edges, namespace.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcluster {
		edges = append(edges, namespace.EdgeCluster)
	}
	if m.clearedapplications {
		edges = append(edges, namespace.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeCluster:
		return m.clearedcluster
	case namespace.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	case namespace.EdgeCluster:
		m.ClearCluster()
		return nil
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeCluster:
		m.ResetCluster()
		return nil
	case namespace.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// PermissionMutation represents an operation that mutate the Permissions
// nodes in the graph.
type PermissionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	method          *string
	fullpath        *string
	action          *string
	summary         *string
	controlLevel    *int
	addcontrolLevel *int
	status          *int
	addstatus       *int
	createdAt       *time.Time
	updatedAt       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Permission, error)
	predicates      []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows to manage the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for $n.Name.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the id field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMethod sets the method field.
func (m *PermissionMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the method value in the mutation.
func (m *PermissionMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old method value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod reset all changes of the "method" field.
func (m *PermissionMutation) ResetMethod() {
	m.method = nil
}

// SetFullpath sets the fullpath field.
func (m *PermissionMutation) SetFullpath(s string) {
	m.fullpath = &s
}

// Fullpath returns the fullpath value in the mutation.
func (m *PermissionMutation) Fullpath() (r string, exists bool) {
	v := m.fullpath
	if v == nil {
		return
	}
	return *v, true
}

// OldFullpath returns the old fullpath value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldFullpath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFullpath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFullpath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullpath: %w", err)
	}
	return oldValue.Fullpath, nil
}

// ResetFullpath reset all changes of the "fullpath" field.
func (m *PermissionMutation) ResetFullpath() {
	m.fullpath = nil
}

// SetAction sets the action field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the action value in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old action value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAction is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction reset all changes of the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
}

// SetSummary sets the summary field.
func (m *PermissionMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the summary value in the mutation.
func (m *PermissionMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old summary value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSummary is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary reset all changes of the "summary" field.
func (m *PermissionMutation) ResetSummary() {
	m.summary = nil
}

// SetControlLevel sets the controlLevel field.
func (m *PermissionMutation) SetControlLevel(i int) {
	m.controlLevel = &i
	m.addcontrolLevel = nil
}

// ControlLevel returns the controlLevel value in the mutation.
func (m *PermissionMutation) ControlLevel() (r int, exists bool) {
	v := m.controlLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldControlLevel returns the old controlLevel value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldControlLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldControlLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldControlLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlLevel: %w", err)
	}
	return oldValue.ControlLevel, nil
}

// AddControlLevel adds i to controlLevel.
func (m *PermissionMutation) AddControlLevel(i int) {
	if m.addcontrolLevel != nil {
		*m.addcontrolLevel += i
	} else {
		m.addcontrolLevel = &i
	}
}

// AddedControlLevel returns the value that was added to the controlLevel field in this mutation.
func (m *PermissionMutation) AddedControlLevel() (r int, exists bool) {
	v := m.addcontrolLevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetControlLevel reset all changes of the "controlLevel" field.
func (m *PermissionMutation) ResetControlLevel() {
	m.controlLevel = nil
	m.addcontrolLevel = nil
}

// SetStatus sets the status field.
func (m *PermissionMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *PermissionMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *PermissionMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *PermissionMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *PermissionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the createdAt field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.method != nil {
		fields = append(fields, permission.FieldMethod)
	}
	if m.fullpath != nil {
		fields = append(fields, permission.FieldFullpath)
	}
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	if m.summary != nil {
		fields = append(fields, permission.FieldSummary)
	}
	if m.controlLevel != nil {
		fields = append(fields, permission.FieldControlLevel)
	}
	if m.status != nil {
		fields = append(fields, permission.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldMethod:
		return m.Method()
	case permission.FieldFullpath:
		return m.Fullpath()
	case permission.FieldAction:
		return m.Action()
	case permission.FieldSummary:
		return m.Summary()
	case permission.FieldControlLevel:
		return m.ControlLevel()
	case permission.FieldStatus:
		return m.Status()
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldMethod:
		return m.OldMethod(ctx)
	case permission.FieldFullpath:
		return m.OldFullpath(ctx)
	case permission.FieldAction:
		return m.OldAction(ctx)
	case permission.FieldSummary:
		return m.OldSummary(ctx)
	case permission.FieldControlLevel:
		return m.OldControlLevel(ctx)
	case permission.FieldStatus:
		return m.OldStatus(ctx)
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case permission.FieldFullpath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullpath(v)
		return nil
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permission.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case permission.FieldControlLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlLevel(v)
		return nil
	case permission.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcontrolLevel != nil {
		fields = append(fields, permission.FieldControlLevel)
	}
	if m.addstatus != nil {
		fields = append(fields, permission.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldControlLevel:
		return m.AddedControlLevel()
	case permission.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldControlLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddControlLevel(v)
		return nil
	case permission.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldMethod:
		m.ResetMethod()
		return nil
	case permission.FieldFullpath:
		m.ResetFullpath()
		return nil
	case permission.FieldAction:
		m.ResetAction()
		return nil
	case permission.FieldSummary:
		m.ResetSummary()
		return nil
	case permission.FieldControlLevel:
		m.ResetControlLevel()
		return nil
	case permission.FieldStatus:
		m.ResetStatus()
		return nil
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ProjectMutation represents an operation that mutate the Projects
// nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	projectName         *string
	proType             *string
	description         *string
	gitlab              *string
	port                *int
	addport             *int
	debugPort           *int
	adddebugPort        *int
	createdAt           *time.Time
	updatedAt           *time.Time
	clearedFields       map[string]struct{}
	applications        map[int]struct{}
	removedapplications map[int]struct{}
	clearedapplications bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows to manage the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for $n.Name.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the id field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProjectName sets the projectName field.
func (m *ProjectMutation) SetProjectName(s string) {
	m.projectName = &s
}

// ProjectName returns the projectName value in the mutation.
func (m *ProjectMutation) ProjectName() (r string, exists bool) {
	v := m.projectName
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old projectName value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProjectName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ResetProjectName reset all changes of the "projectName" field.
func (m *ProjectMutation) ResetProjectName() {
	m.projectName = nil
}

// SetProType sets the proType field.
func (m *ProjectMutation) SetProType(s string) {
	m.proType = &s
}

// ProType returns the proType value in the mutation.
func (m *ProjectMutation) ProType() (r string, exists bool) {
	v := m.proType
	if v == nil {
		return
	}
	return *v, true
}

// OldProType returns the old proType value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldProType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProType: %w", err)
	}
	return oldValue.ProType, nil
}

// ResetProType reset all changes of the "proType" field.
func (m *ProjectMutation) ResetProType() {
	m.proType = nil
}

// SetDescription sets the description field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetGitlab sets the gitlab field.
func (m *ProjectMutation) SetGitlab(s string) {
	m.gitlab = &s
}

// Gitlab returns the gitlab value in the mutation.
func (m *ProjectMutation) Gitlab() (r string, exists bool) {
	v := m.gitlab
	if v == nil {
		return
	}
	return *v, true
}

// OldGitlab returns the old gitlab value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldGitlab(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGitlab is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGitlab requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitlab: %w", err)
	}
	return oldValue.Gitlab, nil
}

// ResetGitlab reset all changes of the "gitlab" field.
func (m *ProjectMutation) ResetGitlab() {
	m.gitlab = nil
}

// SetPort sets the port field.
func (m *ProjectMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the port value in the mutation.
func (m *ProjectMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old port value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to port.
func (m *ProjectMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the port field in this mutation.
func (m *ProjectMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort reset all changes of the "port" field.
func (m *ProjectMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetDebugPort sets the debugPort field.
func (m *ProjectMutation) SetDebugPort(i int) {
	m.debugPort = &i
	m.adddebugPort = nil
}

// DebugPort returns the debugPort value in the mutation.
func (m *ProjectMutation) DebugPort() (r int, exists bool) {
	v := m.debugPort
	if v == nil {
		return
	}
	return *v, true
}

// OldDebugPort returns the old debugPort value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldDebugPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDebugPort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDebugPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebugPort: %w", err)
	}
	return oldValue.DebugPort, nil
}

// AddDebugPort adds i to debugPort.
func (m *ProjectMutation) AddDebugPort(i int) {
	if m.adddebugPort != nil {
		*m.adddebugPort += i
	} else {
		m.adddebugPort = &i
	}
}

// AddedDebugPort returns the value that was added to the debugPort field in this mutation.
func (m *ProjectMutation) AddedDebugPort() (r int, exists bool) {
	v := m.adddebugPort
	if v == nil {
		return
	}
	return *v, true
}

// ResetDebugPort reset all changes of the "debugPort" field.
func (m *ProjectMutation) ResetDebugPort() {
	m.debugPort = nil
	m.adddebugPort = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddApplicationIDs adds the applications edge to Application by ids.
func (m *ProjectMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the applications edge to Application.
func (m *ProjectMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared returns if the edge applications was cleared.
func (m *ProjectMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the applications edge to Application by ids.
func (m *ProjectMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed ids of applications.
func (m *ProjectMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the applications ids in the mutation.
func (m *ProjectMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications reset all changes of the "applications" edge.
func (m *ProjectMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.projectName != nil {
		fields = append(fields, project.FieldProjectName)
	}
	if m.proType != nil {
		fields = append(fields, project.FieldProType)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.gitlab != nil {
		fields = append(fields, project.FieldGitlab)
	}
	if m.port != nil {
		fields = append(fields, project.FieldPort)
	}
	if m.debugPort != nil {
		fields = append(fields, project.FieldDebugPort)
	}
	if m.createdAt != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldProjectName:
		return m.ProjectName()
	case project.FieldProType:
		return m.ProType()
	case project.FieldDescription:
		return m.Description()
	case project.FieldGitlab:
		return m.Gitlab()
	case project.FieldPort:
		return m.Port()
	case project.FieldDebugPort:
		return m.DebugPort()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldProjectName:
		return m.OldProjectName(ctx)
	case project.FieldProType:
		return m.OldProType(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldGitlab:
		return m.OldGitlab(ctx)
	case project.FieldPort:
		return m.OldPort(ctx)
	case project.FieldDebugPort:
		return m.OldDebugPort(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case project.FieldProType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProType(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldGitlab:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitlab(v)
		return nil
	case project.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case project.FieldDebugPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebugPort(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, project.FieldPort)
	}
	if m.adddebugPort != nil {
		fields = append(fields, project.FieldDebugPort)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldPort:
		return m.AddedPort()
	case project.FieldDebugPort:
		return m.AddedDebugPort()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case project.FieldDebugPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDebugPort(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldProjectName:
		m.ResetProjectName()
		return nil
	case project.FieldProType:
		m.ResetProType()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldGitlab:
		m.ResetGitlab()
		return nil
	case project.FieldPort:
		m.ResetPort()
		return nil
	case project.FieldDebugPort:
		m.ResetDebugPort()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.applications != nil {
		edges = append(edges, project.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedapplications != nil {
		edges = append(edges, project.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplications {
		edges = append(edges, project.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// RoleMutation represents an operation that mutate the Roles
// nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	status        *int
	addstatus     *int
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows to manage the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for $n.Name.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the id field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetStatus sets the status field.
func (m *RoleMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *RoleMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *RoleMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *RoleMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the createdAt field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldStatus:
		return m.Status()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Role edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password      *string
	initial       *bool
	oauser        *string
	name          *string
	telephone     *string
	email         *string
	avatar        *string
	super         *bool
	status        *int
	addstatus     *int
	lastLogin     *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the username field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old username value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of password.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the field password was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetInitial sets the initial field.
func (m *UserMutation) SetInitial(b bool) {
	m.initial = &b
}

// Initial returns the initial value in the mutation.
func (m *UserMutation) Initial() (r bool, exists bool) {
	v := m.initial
	if v == nil {
		return
	}
	return *v, true
}

// OldInitial returns the old initial value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldInitial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInitial is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInitial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitial: %w", err)
	}
	return oldValue.Initial, nil
}

// ResetInitial reset all changes of the "initial" field.
func (m *UserMutation) ResetInitial() {
	m.initial = nil
}

// SetOauser sets the oauser field.
func (m *UserMutation) SetOauser(s string) {
	m.oauser = &s
}

// Oauser returns the oauser value in the mutation.
func (m *UserMutation) Oauser() (r string, exists bool) {
	v := m.oauser
	if v == nil {
		return
	}
	return *v, true
}

// OldOauser returns the old oauser value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldOauser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOauser is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOauser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauser: %w", err)
	}
	return oldValue.Oauser, nil
}

// ClearOauser clears the value of oauser.
func (m *UserMutation) ClearOauser() {
	m.oauser = nil
	m.clearedFields[user.FieldOauser] = struct{}{}
}

// OauserCleared returns if the field oauser was cleared in this mutation.
func (m *UserMutation) OauserCleared() bool {
	_, ok := m.clearedFields[user.FieldOauser]
	return ok
}

// ResetOauser reset all changes of the "oauser" field.
func (m *UserMutation) ResetOauser() {
	m.oauser = nil
	delete(m.clearedFields, user.FieldOauser)
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetTelephone sets the telephone field.
func (m *UserMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the telephone value in the mutation.
func (m *UserMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old telephone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelephone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ClearTelephone clears the value of telephone.
func (m *UserMutation) ClearTelephone() {
	m.telephone = nil
	m.clearedFields[user.FieldTelephone] = struct{}{}
}

// TelephoneCleared returns if the field telephone was cleared in this mutation.
func (m *UserMutation) TelephoneCleared() bool {
	_, ok := m.clearedFields[user.FieldTelephone]
	return ok
}

// ResetTelephone reset all changes of the "telephone" field.
func (m *UserMutation) ResetTelephone() {
	m.telephone = nil
	delete(m.clearedFields, user.FieldTelephone)
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the avatar field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the avatar value in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old avatar value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of avatar.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the field avatar was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar reset all changes of the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetSuper sets the super field.
func (m *UserMutation) SetSuper(b bool) {
	m.super = &b
}

// Super returns the super value in the mutation.
func (m *UserMutation) Super() (r bool, exists bool) {
	v := m.super
	if v == nil {
		return
	}
	return *v, true
}

// OldSuper returns the old super value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldSuper(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuper is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuper: %w", err)
	}
	return oldValue.Super, nil
}

// ResetSuper reset all changes of the "super" field.
func (m *UserMutation) ResetSuper() {
	m.super = nil
}

// SetStatus sets the status field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of status.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the field status was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus reset all changes of the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetLastLogin sets the lastLogin field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.lastLogin = &t
}

// LastLogin returns the lastLogin value in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.lastLogin
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old lastLogin value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastLogin is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of lastLogin.
func (m *UserMutation) ClearLastLogin() {
	m.lastLogin = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the field lastLogin was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin reset all changes of the "lastLogin" field.
func (m *UserMutation) ResetLastLogin() {
	m.lastLogin = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetCreatedAt sets the createdAt field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.initial != nil {
		fields = append(fields, user.FieldInitial)
	}
	if m.oauser != nil {
		fields = append(fields, user.FieldOauser)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.telephone != nil {
		fields = append(fields, user.FieldTelephone)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.super != nil {
		fields = append(fields, user.FieldSuper)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.lastLogin != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldInitial:
		return m.Initial()
	case user.FieldOauser:
		return m.Oauser()
	case user.FieldName:
		return m.Name()
	case user.FieldTelephone:
		return m.Telephone()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldSuper:
		return m.Super()
	case user.FieldStatus:
		return m.Status()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldInitial:
		return m.OldInitial(ctx)
	case user.FieldOauser:
		return m.OldOauser(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldTelephone:
		return m.OldTelephone(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldSuper:
		return m.OldSuper(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldInitial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitial(v)
		return nil
	case user.FieldOauser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauser(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldSuper:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuper(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldOauser) {
		fields = append(fields, user.FieldOauser)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldTelephone) {
		fields = append(fields, user.FieldTelephone)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldOauser:
		m.ClearOauser()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldTelephone:
		m.ClearTelephone()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldInitial:
		m.ResetInitial()
		return nil
	case user.FieldOauser:
		m.ResetOauser()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldTelephone:
		m.ResetTelephone()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldSuper:
		m.ResetSuper()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
